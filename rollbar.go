package logrus_rollbar

import (
	"bytes"
	"errors"
	"fmt"
	"net/http"
	"os"

	"github.com/rollbar/rollbar-go"
	"github.com/sirupsen/logrus"
	"gopkg.in/errgo.v1"
)

var (
	SeverityCritical = "critical"
	ErrgoStackSkip   = 15
)

// RollbarHook delivers logs to a rollbar server.
type RollbarHook struct {
	Sender
	client *rollbar.Client
	levels []logrus.Level
}

// NewRollbarHook creates a hook to be added to an instance of logger
// and initializes the rollbar client.
// This method sets the timeout to 100 milliseconds.
func NewRollbarHook(token string, levels []logrus.Level) (*RollbarHook, error) {
	hostname, _ := os.Hostname()
	client := rollbar.New("", "development", "", hostname, "")

	return NewWithClientRollbarHook(client, levels)
}

// NewWithClientRollbarHook creates a hook using an initialized rollbar client.
// This method sets the timeout to 100 milliseconds.
func NewWithClientRollbarHook(client *rollbar.Client, levels []logrus.Level) (*RollbarHook, error) {
	return &RollbarHook{
		Sender: &RollbarSender{},
		client: client,
		levels: levels,
	}, nil
}

// NewAsyncRollbarHook creates a hook same as NewRollbarHook, but in asynchronous
// mode.
func NewAsyncRollbarHook(token string, levels []logrus.Level) (*RollbarHook, error) {
	hostname, _ := os.Hostname()
	client := rollbar.NewAsync("", "development", "", hostname, "")

	return NewAsyncWithClientRollbarHook(client, levels)
}

// NewAsyncWithClientRollbarHook creates a hook same as NewWithClientRollbarHook,
// but in asynchronous mode.
func NewAsyncWithClientRollbarHook(client *rollbar.Client, levels []logrus.Level) (*RollbarHook, error) {
	return &RollbarHook{
		Sender: &RollbarSender{},
		client: client,
		levels: levels,
	}, nil
}

// Fire is called when an event should be sent to rollbar
// Special fields that rollbar uses to give more information to the server
// are extracted from entry.Data (if they are found)
func (hook *RollbarHook) Fire(entry *logrus.Entry) error {
	var req *http.Request

	if r, ok := entry.Data["req"]; ok {
		upstreamReq, ok := r.(*http.Request)
		if ok {
			req, _ = http.NewRequest(upstreamReq.Method, upstreamReq.URL.String(), nil)
			req.RemoteAddr = upstreamReq.RemoteAddr
			for key, val := range upstreamReq.Header {
				// We don't want to log credentials
				if key == "Authorization" {
					continue
				}

				req.Header[key] = val
			}

			// Replacing the request struct by something simpler in the entry fields
			entry.Data["req"] = fmt.Sprintf(
				"%s %s %s",
				req.Method, req.URL, req.RemoteAddr,
			)
		}
	}

	// All the fields which aren't level|msg|error|time|req are added
	// to the headers of the request which will be sent to rollbar
	fields := map[string]interface{}{}
	for val, key := range entry.Data {
		if val != "level" && val != "msg" && val != "error" && val != "time" && val != "req" {
			fields[val] = key
		}
	}

	// If there is an error field, we want it to be part of rollbar ticket name
	var (
		err error
	)

	msg := entry.Message
	if entry.Data["msg"] != nil {
		msg = fmt.Sprintf("%s - %v", msg, entry.Data["msg"])
	}

	if entry.Data["error"] != nil {
		err = entry.Data["error"].(error)

		errorTxt := new(bytes.Buffer)
		errorTxt.WriteString(err.Error())
		errorTxt.WriteString(" - " + msg)

		msg := errorTxt.String()

		switch err.(type) {
		case *errgo.Err:
			// SkipLevel is set to 15, why: the stack is generated by the rollbar lib
			// just before sending the error. So when the Stack() method of the
			// wrapped Error is called, it is deep in the code of 1. logrus, 2. this
			// hook, 3. rollbar, so there are 15 levels of stack trace we want to
			// hide in order to have a clean error.
			err = Wrap(msg, err, ErrgoStackSkip)
		default:
			err = Wrap(msg, err, 0)
		}
	} else {
		err = errors.New(msg)
	}

	severity := rollbar.ERR
	if entry.Data["severity"] == SeverityCritical {
		severity = rollbar.CRIT
	}

	if req == nil {
		hook.Sender.Error(severity, err, fields)
	} else {
		hook.Sender.RequestError(severity, req, err, fields)
	}

	return nil
}

func (h *RollbarHook) Levels() []logrus.Level {
	return []logrus.Level{
		logrus.ErrorLevel,
		logrus.FatalLevel,
		logrus.PanicLevel,
	}
}
